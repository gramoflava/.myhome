#!/usr/bin/env python3
"""
safesync — robust, resumable directory sync with visual progress

REQUIREMENTS:
    1. Large files (like ML models) should be synced but NOT re-copied every time
       - Uses size + modification time comparison by default (fast)
       - Optional checksum verification with -c flag (thorough but slow)
    2. Interrupted transfers must resume from where they left off, not restart
       - Uses --partial to keep partial files
       - Uses --inplace to update files in place (enables true resume)
    3. Files deleted from source should be deleted from destination
       - Uses --delete-delay by default (deletes after transfer completes)
       - Use --no-delete to preserve extra files in destination
    4. No permission errors on cross-filesystem syncs
       - Uses -rlDht instead of -a (no permissions, no owner, no group)
       - Preserves times for proper comparison

FEATURES:
    - Visual file list with status markers:
        ○ pending (queued for transfer)
        → copying (currently transferring)
        ✓ done (successfully transferred)
        × deleted (removed from destination)
        ! error (transfer failed)
    - Real-time progress bar with file count
    - Transfer speed and volume display (updated during large file transfers)
    - Pre-scan shows all files with total size before transfer begins
    - Final summary with statistics

COMPARISON MODES:
    Default:        size + modification time (recommended for most cases)
    --checksum:     content checksum (use for critical data verification)
    --size-only:    file size only (fastest, may miss same-size changes)
"""

import argparse
import subprocess
import sys
import os
import re
import shutil
import time
from dataclasses import dataclass, field
from enum import Enum
from typing import Optional

# ============================================================================
# ANSI TERMINAL CONTROL
# ============================================================================

class Term:
    """ANSI terminal control codes"""
    RESET = "\x1b[0m"
    RED = "\x1b[31m"
    GREEN = "\x1b[32m"
    YELLOW = "\x1b[33m"
    BLUE = "\x1b[34m"
    CYAN = "\x1b[36m"
    DIM = "\x1b[2m"
    BOLD = "\x1b[1m"

    # Cursor movement
    UP = "\x1b[A"
    DOWN = "\x1b[B"
    CLEAR_LINE = "\x1b[2K"
    SAVE_POS = "\x1b[s"
    RESTORE_POS = "\x1b[u"
    HIDE_CURSOR = "\x1b[?25l"
    SHOW_CURSOR = "\x1b[?25h"

    @staticmethod
    def move_up(n: int) -> str:
        return f"\x1b[{n}A" if n > 0 else ""

    @staticmethod
    def move_down(n: int) -> str:
        return f"\x1b[{n}B" if n > 0 else ""

    @staticmethod
    def move_to_col(n: int) -> str:
        return f"\x1b[{n}G"

def is_tty() -> bool:
    """Check if stdout is a terminal"""
    return sys.stdout.isatty()

def format_bytes(n: int) -> str:
    """Format bytes as human-readable string"""
    for unit in ['B', 'KB', 'MB', 'GB', 'TB']:
        if abs(n) < 1024:
            if unit == 'B':
                return f"{n}{unit}"
            return f"{n:.1f}{unit}"
        n /= 1024
    return f"{n:.1f}PB"

def color(text: str, c: str) -> str:
    """Apply color if terminal supports it"""
    if is_tty():
        return f"{c}{text}{Term.RESET}"
    return text

# ============================================================================
# DATA STRUCTURES
# ============================================================================

class FileStatus(Enum):
    PENDING = "pending"      # Queued for transfer
    COPYING = "copying"      # Currently being transferred
    DONE = "done"            # Successfully transferred
    SKIPPED = "skipped"      # Unchanged, skipped
    DELETED = "deleted"      # Will be/was deleted from dest
    ERROR = "error"          # Transfer failed

@dataclass
class FileEntry:
    """Represents a file in the transfer list"""
    path: str
    status: FileStatus = FileStatus.PENDING
    reason: str = ""         # Why it needs transfer (size/time/checksum/new)
    size: int = 0
    is_delete: bool = False

    def status_marker(self) -> str:
        """Return colored status marker"""
        markers = {
            FileStatus.PENDING: ("○", Term.DIM),
            FileStatus.COPYING: ("→", Term.CYAN + Term.BOLD),
            FileStatus.DONE: ("✓", Term.GREEN),
            FileStatus.SKIPPED: ("·", Term.DIM),
            FileStatus.DELETED: ("×", Term.RED),
            FileStatus.ERROR: ("!", Term.RED + Term.BOLD),
        }
        marker, c = markers.get(self.status, ("?", ""))
        return color(marker, c)

    def display_line(self, max_width: int = 70) -> str:
        """Format file entry for display"""
        marker = self.status_marker()

        # Truncate path if too long
        path = self.path
        if len(path) > max_width:
            path = "…" + path[-(max_width-1):]

        # Add reason in parentheses for pending files
        suffix = ""
        if self.status == FileStatus.PENDING and self.reason:
            suffix = color(f" ({self.reason})", Term.DIM)
        elif self.status == FileStatus.DELETED:
            suffix = color(" (delete)", Term.DIM)

        return f"  {marker} {path}{suffix}"

@dataclass
class SyncStats:
    """Transfer statistics"""
    total_files: int = 0
    transferred: int = 0
    skipped: int = 0
    deleted: int = 0
    errors: int = 0
    bytes_transferred: int = 0
    bytes_total: int = 0
    current_speed: str = ""      # e.g., "45.3MB/s"
    current_file_bytes: int = 0  # Bytes transferred of current file
    current_file_total: int = 0  # Total bytes of current file
    current_file_pct: int = 0    # Percentage of current file

# ============================================================================
# RSYNC OUTPUT PARSING
# ============================================================================

def parse_itemize(line: str) -> tuple[str, str, bool]:
    """
    Parse rsync --itemize-changes output.
    Returns: (filename, reason, is_delete)

    Format: YXcstpoguax path
    Y = update type: < sending, > receiving, c local change, h hard link, . unchanged, * deleting
    X = file type: f file, d directory, L symlink, D device, S special
    c = checksum differs
    s = size differs
    t = time differs
    p = permissions differ
    o = owner differs
    g = group differs
    u = reserved
    a = ACL differs
    x = extended attrs differ

    For new files: >f+++++++++ filename (all '+' means new)
    """
    if not line or len(line) < 12:
        return ("", "", False)

    # Check for delete marker
    if line.startswith("*deleting"):
        path = line[10:].strip()
        return (path, "delete", True)

    # Parse itemize format
    flags = line[:11]
    path = line[12:].strip() if len(line) > 12 else ""

    if not path:
        return ("", "", False)

    # Skip if not a file transfer indicator
    if flags[0] not in '<>ch':
        return ("", "", False)

    # Check if it's a completely new file (all '+' after type indicator)
    if '+' in flags[2:]:
        # Count '+' - if most positions are '+', it's a new file
        plus_count = flags[2:].count('+')
        if plus_count >= 5:  # Most of the change flags are '+'
            return (path, "new", False)

    # Determine reason for transfer from change flags
    reasons = []
    if len(flags) > 2 and flags[2] == 'c':
        reasons.append("checksum")
    if len(flags) > 3 and flags[3] == 's':
        reasons.append("size")
    if len(flags) > 4 and flags[4] == 't':
        reasons.append("time")

    reason = "/".join(reasons) if reasons else "update"
    is_delete = flags[0] == '*'

    return (path, reason, is_delete)

# ============================================================================
# PROGRESS DISPLAY
# ============================================================================

class ProgressDisplay:
    """Manages the terminal display with line updates"""

    def __init__(self, max_display: int = 15):
        self.max_display = max_display
        self.files: list[FileEntry] = []
        self.stats = SyncStats()
        self.header_lines = 0
        self.file_list_start = 0
        self.initialized = False
        self.use_fancy = is_tty()
        self.progress_line_shown = False

    def print_header(self, config: dict):
        """Print transfer configuration header"""
        lines = [
            "",
            color("Transfer configuration:", Term.BLUE + Term.BOLD),
            f"  Source:      {config['source']}",
            f"  Destination: {config['dest']}",
        ]

        if config.get('is_remote'):
            lines.append(f"  SSH port:    {config.get('port', 22)}")
        else:
            lines.append("  Mode:        Local")

        # Comparison mode
        if config.get('checksum'):
            compare_mode = "checksum (thorough)"
        elif config.get('size_only'):
            compare_mode = "size only (fastest)"
        else:
            compare_mode = "size + time (default)"
        lines.append(f"  Compare:     {compare_mode}")
        lines.append(f"  Delete:      {'enabled' if config.get('delete') else 'disabled'}")

        if config.get('dry_run'):
            lines.append(color("  [DRY RUN - no changes will be made]", Term.YELLOW))

        lines.append("")

        for line in lines:
            print(line)

        self.header_lines = len(lines)

    def print_scanning(self):
        """Show scanning message"""
        print(color("Scanning files...", Term.BLUE))
        sys.stdout.flush()

    def set_files(self, files: list[FileEntry], total_bytes: int = 0):
        """Set the file list and print initial state"""
        self.files = files
        self.stats.total_files = len([f for f in files if not f.is_delete])
        self.stats.bytes_total = total_bytes

        # Clear scanning message and print file list
        if self.use_fancy:
            print(Term.CLEAR_LINE + Term.UP + Term.CLEAR_LINE, end="")

        # Count by type
        to_transfer = [f for f in files if not f.is_delete]
        to_delete = [f for f in files if f.is_delete]

        if not files:
            print(color("✓ Already in sync, nothing to transfer", Term.GREEN))
            return

        summary_parts = []
        if to_transfer:
            if total_bytes > 0:
                summary_parts.append(f"{len(to_transfer)} to transfer ({format_bytes(total_bytes)})")
            else:
                summary_parts.append(f"{len(to_transfer)} to transfer")
        if to_delete:
            summary_parts.append(f"{len(to_delete)} to delete")

        print(color(f"Found {', '.join(summary_parts)}:", Term.BLUE))
        print()

        self.file_list_start = self.header_lines + 3

        # Print file list (limited to max_display)
        display_files = files[:self.max_display]
        for f in display_files:
            print(f.display_line())

        if len(files) > self.max_display:
            remaining = len(files) - self.max_display
            print(color(f"  ... and {remaining} more files", Term.DIM))

        # Progress line (cursor stays here for updates)
        print()
        self._print_progress_line()
        # Don't print newline - cursor stays on progress line for in-place updates
        self.initialized = True
        self.progress_line_shown = True
        sys.stdout.flush()

    def _print_progress_line(self):
        """Print/update the progress line"""
        total = len(self.files)
        done = self.stats.transferred + self.stats.deleted + self.stats.errors
        pct = int(done / total * 100) if total > 0 else 0

        # Create progress bar
        bar_width = 20
        filled = int(bar_width * done / total) if total > 0 else 0
        bar = "█" * filled + "░" * (bar_width - filled)

        # Build line components
        parts = [f"[{bar}] {done}/{total}"]

        # Add bytes transferred/total if we have that info
        if self.stats.bytes_total > 0:
            bytes_done = self.stats.bytes_transferred + self.stats.current_file_bytes
            parts.append(f"{format_bytes(bytes_done)}/{format_bytes(self.stats.bytes_total)}")
        elif self.stats.bytes_transferred > 0:
            parts.append(format_bytes(self.stats.bytes_transferred))

        # Add current speed if available
        if self.stats.current_speed:
            parts.append(self.stats.current_speed)

        # Add current file progress if transferring a large file
        if self.stats.current_file_pct > 0 and self.stats.current_file_pct < 100:
            parts.append(f"file: {self.stats.current_file_pct}%")

        line = "  " + " | ".join(parts)
        print(color(line, Term.CYAN), end="")
        sys.stdout.flush()

    def _update_progress(self):
        """Update the progress line in place (cursor should be on this line)"""
        if not self.use_fancy or not self.progress_line_shown:
            return

        # Simple approach: cursor is on progress line, just overwrite
        sys.stdout.write("\r" + Term.CLEAR_LINE)
        self._print_progress_line()
        sys.stdout.flush()

    def update_file(self, path: str, status: FileStatus):
        """Update a file's status and refresh display"""
        for i, f in enumerate(self.files):
            if f.path == path:
                f.status = status

                # Update stats
                if status == FileStatus.DONE:
                    if f.is_delete:
                        self.stats.deleted += 1
                    else:
                        self.stats.transferred += 1
                elif status == FileStatus.ERROR:
                    self.stats.errors += 1

                # Note: Disabled fancy file line updates - unreliable over SSH
                # The progress bar still updates in real-time

                # Update progress bar
                if status in (FileStatus.DONE, FileStatus.ERROR):
                    self._update_progress()

                break

    def _update_line(self, idx: int, entry: FileEntry):
        """Update a specific line in the file list"""
        # Calculate how many lines to go up from current position
        # Layout: file list, ["... more"], empty line, progress line, empty line
        # Current cursor is after the last empty line
        visible_files = min(len(self.files), self.max_display)
        has_more_line = len(self.files) > self.max_display

        # Lines from end: empty(1) + progress(1) + empty(1) + [more(1)] + remaining files
        lines_from_end = 3  # two empty lines + progress line
        if has_more_line:
            lines_from_end += 1
        lines_from_end += (visible_files - 1 - idx)

        # Move up, clear line, print new content, move back down
        sys.stdout.write(Term.SAVE_POS)
        sys.stdout.write(Term.move_up(lines_from_end))
        sys.stdout.write("\r" + Term.CLEAR_LINE)
        sys.stdout.write(entry.display_line())
        sys.stdout.write(Term.RESTORE_POS)
        sys.stdout.flush()

    def mark_copying(self, path: str):
        """Mark a file as currently being copied"""
        self.update_file(path, FileStatus.COPYING)

    def update_transfer_progress(self, bytes_done: int, pct: int, speed: str):
        """Update current file transfer progress"""
        self.stats.current_file_bytes = bytes_done
        self.stats.current_file_pct = pct
        if speed:
            self.stats.current_speed = speed
        self._update_progress()

    def mark_done(self, path: str):
        """Mark a file as successfully transferred"""
        # Add current file bytes to total transferred
        for f in self.files:
            if f.path == path and not f.is_delete:
                self.stats.bytes_transferred += f.size
                break
        # Reset current file progress
        self.stats.current_file_bytes = 0
        self.stats.current_file_pct = 0
        self.update_file(path, FileStatus.DONE)

    def mark_deleted(self, path: str):
        """Mark a file as deleted"""
        for f in self.files:
            if f.path == path and f.is_delete:
                self.update_file(path, FileStatus.DONE)  # Use DONE with × marker
                break

    def print_summary(self, dry_run: bool = False):
        """Print final summary"""
        print()

        if dry_run:
            print(color("Dry run completed", Term.GREEN + Term.BOLD))
        elif self.stats.errors > 0:
            print(color("Transfer completed with errors", Term.YELLOW + Term.BOLD))
        else:
            print(color("Transfer completed successfully", Term.GREEN + Term.BOLD))

        print()
        print("Summary:")

        if self.stats.transferred > 0:
            transferred_str = f"{self.stats.transferred} file(s) transferred"
            if self.stats.bytes_transferred > 0:
                transferred_str += f" ({format_bytes(self.stats.bytes_transferred)})"
            print(f"  {color('✓', Term.GREEN)} {transferred_str}")

        if self.stats.deleted > 0:
            print(f"  {color('×', Term.RED)} {self.stats.deleted} file(s) deleted")

        skipped = self.stats.total_files - self.stats.transferred - self.stats.errors
        if skipped > 0:
            print(f"  {color('·', Term.DIM)} {skipped} file(s) unchanged")

        if self.stats.errors > 0:
            print(f"  {color('!', Term.RED)} {self.stats.errors} error(s)")

        print()

# ============================================================================
# RSYNC WRAPPER
# ============================================================================

def check_rsync() -> bool:
    """Check if rsync is available and version is adequate"""
    if not shutil.which("rsync"):
        print(color("ERROR", Term.RED) + ": rsync not found. Install it first:")
        print("  macOS:  brew install rsync")
        print("  Linux:  apt install rsync / yum install rsync")
        return False

    result = subprocess.run(["rsync", "--version"], capture_output=True, text=True)
    version_match = re.search(r'(\d+)\.(\d+)\.(\d+)', result.stdout)

    if version_match:
        major, minor = int(version_match.group(1)), int(version_match.group(2))
        if major < 3 or (major == 3 and minor < 1):
            print(color("WARN", Term.YELLOW) + f": rsync {version_match.group(0)} detected (3.1.0+ recommended)")
            print("  macOS built-in rsync is outdated. Install via: brew install rsync")

    return True

def build_rsync_opts(config: dict, for_scan: bool = False) -> list[str]:
    """Build rsync command options"""
    opts = [
        "-rlDht",         # recursive, links, devices, human-readable, times (no perms/owner)
        "--partial",      # Keep partial files for resume
        "--inplace",      # Update files in place (better for large files, enables resume)
        "--mkpath",       # Create destination if missing
        "--itemize-changes",  # Show what changed (for parsing)
    ]

    # Add progress output for real transfers (not scanning)
    if not for_scan:
        opts.append("--progress")  # Show per-file progress with speed

    # Remote transfer options
    if config.get('is_remote'):
        port = config.get('port', 22)
        opts.extend(["-e", f"ssh -p {port}"])
        opts.append("--timeout=60")

    # Comparison method
    # Default: size + modification time (fast, good for most cases)
    # With --checksum: verify content via checksums (slow but thorough)
    # With --size-only: ignore time, only compare size (fastest, less accurate)
    if config.get('checksum'):
        opts.append("-c")
    elif config.get('size_only'):
        opts.append("--size-only")
    # else: default rsync behavior (size + mtime)

    # Delete handling
    if config.get('delete'):
        opts.append("--delete-delay")

    # Dry run
    if config.get('dry_run'):
        opts.append("--dry-run")

    return opts

def scan_files(config: dict) -> tuple[list[FileEntry], int]:
    """
    Scan source and destination to determine what will be transferred.
    Uses rsync --dry-run --itemize-changes to get the file list.
    Returns: (list of FileEntry, total bytes to transfer)
    """
    opts = build_rsync_opts(config, for_scan=True)

    # Force dry-run for scanning
    if "--dry-run" not in opts:
        opts.append("--dry-run")

    # Add output format to include file size: itemize TAB size TAB path
    opts.append("--out-format=%i\t%l\t%n")

    cmd = ["rsync"] + opts + [config['source'], config['dest']]

    result = subprocess.run(cmd, capture_output=True, text=True)

    files = []
    total_bytes = 0

    for line in result.stdout.splitlines():
        # Skip informational messages (e.g., "created directory ...")
        if line.startswith("created ") or line.startswith("sending ") or line.startswith("receiving "):
            continue

        # Try to parse the extended format with size (tab-separated)
        parts = line.split('\t')
        if len(parts) >= 3:
            itemize_part = parts[0]
            try:
                size = int(parts[1])
            except ValueError:
                size = 0
            path = parts[2]

            # Skip directories (path ends with / or is ./)
            if path.endswith('/') or path == './':
                continue

            # Parse the itemize portion
            _, reason, is_delete = parse_itemize(itemize_part + " " + path)

            # Only include if we got a valid reason
            if reason:
                entry = FileEntry(
                    path=path,
                    reason=reason,
                    is_delete=is_delete,
                    size=size,
                    status=FileStatus.DELETED if is_delete else FileStatus.PENDING
                )
                files.append(entry)
                if not is_delete:
                    total_bytes += size
        else:
            # Fallback to old parsing (for lines without tabs)
            # Only if line looks like itemize format (starts with valid flags)
            if len(line) >= 12 and line[0] in '<>ch*':
                path, reason, is_delete = parse_itemize(line)
                if path and not path.endswith('/') and reason:
                    entry = FileEntry(
                        path=path,
                        reason=reason,
                        is_delete=is_delete,
                        status=FileStatus.DELETED if is_delete else FileStatus.PENDING
                    )
                    files.append(entry)

    return files, total_bytes

def parse_size_string(s: str) -> int:
    """Parse size string like '32.77K', '5.24M', '1,234,567' to bytes"""
    s = s.strip().replace(',', '')
    multipliers = {'K': 1024, 'M': 1024**2, 'G': 1024**3, 'T': 1024**4}

    if s and s[-1] in multipliers:
        try:
            return int(float(s[:-1]) * multipliers[s[-1]])
        except ValueError:
            return 0
    try:
        return int(float(s))
    except ValueError:
        return 0


def parse_progress_line(line: str) -> tuple[int, int, str]:
    """
    Parse rsync --progress output line.
    Formats:
        "     1,234,567  45%   12.34MB/s    0:00:05"
        "        32.77K   0%    0.00kB/s    0:00:00"
        "         5.24M 100%  828.12MB/s    0:00:00 (xfr#1, to-chk=1/3)"
    Returns: (bytes_done, percentage, speed) or (0, 0, "") if not a progress line
    """
    # Match progress format: size (with optional K/M/G suffix), percentage, speed
    match = re.match(r'\s*([\d,.]+[KMGT]?)\s+(\d+)%\s+([\d.]+[kMG]?B/s)', line)
    if match:
        bytes_done = parse_size_string(match.group(1))
        pct = int(match.group(2))
        speed = match.group(3)
        return (bytes_done, pct, speed)
    return (0, 0, "")


def run_sync(config: dict, display: ProgressDisplay) -> int:
    """
    Execute the actual rsync transfer with progress tracking.
    Returns exit code.
    """
    opts = build_rsync_opts(config, for_scan=False)
    cmd = ["rsync"] + opts + [config['source'], config['dest']]

    process = subprocess.Popen(
        cmd,
        stdout=subprocess.PIPE,
        stderr=subprocess.STDOUT,
        text=True,
        bufsize=1
    )

    current_file = None
    last_progress_update = 0

    for line in process.stdout:
        line = line.rstrip()

        # Try to parse as progress line first
        bytes_done, pct, speed = parse_progress_line(line)
        if bytes_done > 0 or pct > 0:
            # Update progress display (but not too often)
            now = time.time()
            if now - last_progress_update > 0.2:  # Update max 5 times/second
                display.update_transfer_progress(bytes_done, pct, speed)
                last_progress_update = now
            continue

        # Parse itemize output
        path, reason, is_delete = parse_itemize(line)

        if path:
            # Mark previous file as done
            if current_file:
                display.mark_done(current_file)

            if is_delete:
                display.mark_deleted(path)
                current_file = None
            else:
                display.mark_copying(path)
                current_file = path

    # Mark last file as done
    if current_file:
        display.mark_done(current_file)

    process.wait()
    return process.returncode

# ============================================================================
# MAIN
# ============================================================================

def main():
    parser = argparse.ArgumentParser(
        description="Robust, resumable directory sync with visual progress",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
    safesync ~/Documents/ user@server:~/backup/
    safesync -p 2222 user@server:/data/ ~/local-data/
    safesync -n ~/source/ ~/destination/  # dry run
    safesync --no-delete ~/source/ ~/dest/
    safesync -c ~/models/ /backup/models/  # checksum verification

Comparison modes:
    Default:      size + modification time (fast, recommended)
    --checksum:   content checksum (slow but thorough)
    --size-only:  file size only (fastest, may miss changes)

Notes:
    - Trailing slash matters: "src/" copies contents, "src" creates subdirectory
    - Interrupted transfers are automatically resumed (--partial --inplace)
    - Files deleted in source are deleted in destination (use --no-delete to keep)
"""
    )

    parser.add_argument("source", help="Source directory (local or remote)")
    parser.add_argument("dest", help="Destination directory (local or remote)")
    parser.add_argument("-p", "--port", type=int, default=int(os.environ.get("RSYNC_SSH_PORT", 22)),
                        help="SSH port (default: 22 or $RSYNC_SSH_PORT)")
    parser.add_argument("-n", "--dry-run", action="store_true",
                        help="Show what would be transferred without doing it")
    parser.add_argument("--no-delete", action="store_true",
                        help="Keep extra files in destination")
    parser.add_argument("-c", "--checksum", action="store_true",
                        help="Use checksums for comparison (slower but thorough)")
    parser.add_argument("--size-only", action="store_true",
                        help="Compare by size only, ignore modification time (fastest)")
    parser.add_argument("-v", "--verbose", action="store_true",
                        help="Show detailed output")

    args = parser.parse_args()

    # Check rsync availability
    if not check_rsync():
        return 1

    # Detect remote transfer
    is_remote = (':' in args.source and not re.match(r'^[A-Za-z]:[/\\]', args.source)) or \
                (':' in args.dest and not re.match(r'^[A-Za-z]:[/\\]', args.dest))

    config = {
        'source': args.source,
        'dest': args.dest,
        'port': args.port,
        'is_remote': is_remote,
        'dry_run': args.dry_run,
        'delete': not args.no_delete,
        'checksum': args.checksum,
        'size_only': args.size_only,
        'verbose': args.verbose,
    }

    # Initialize display
    display = ProgressDisplay()

    # Print header
    display.print_header(config)

    # Scan files
    display.print_scanning()
    files, total_bytes = scan_files(config)
    display.set_files(files, total_bytes)

    if not files:
        return 0

    # Hide cursor during transfer
    if is_tty():
        print(Term.HIDE_CURSOR, end="")

    try:
        # Run sync
        exit_code = run_sync(config, display)

        # Print summary
        display.print_summary(dry_run=args.dry_run)

        if exit_code == 0:
            return 0
        elif exit_code == 23:
            # Partial transfer - check if just permission errors
            print(color("WARN", Term.YELLOW) + ": Some files may have had permission issues")
            return 0
        else:
            print(color("ERROR", Term.RED) + f": rsync exited with code {exit_code}")
            return exit_code

    finally:
        # Show cursor again
        if is_tty():
            print(Term.SHOW_CURSOR, end="")

if __name__ == "__main__":
    sys.exit(main())
